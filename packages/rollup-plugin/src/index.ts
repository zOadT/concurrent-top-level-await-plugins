import type { ImportDeclaration } from "estree";
import type { Plugin, TransformPluginContext } from "rollup";
import { createFilter, type FilterPattern } from "@rollup/pluginutils";
import MagicString from "magic-string";
import hasTopLevelAwait from "./hasTopLevelAwait.js";
import { AsyncModuleTracker } from "./AsyncModuleTracker.js";
import transform from "./transform.js";

function resolveDeclarationSource(
	context: TransformPluginContext,
	id: string,
	importerAttributes: Record<string, string> = {},
	declaration: ImportDeclaration,
) {
	return context.resolve(declaration.source.value as string, id, {
		attributes: Object.fromEntries(
			declaration.attributes.map((attr) => [
				attr.key.type === "Identifier" ? attr.key.name : attr.key.value,
				attr.value.value,
			]),
		),
		importerAttributes,
		custom: {},
	});
}

// Kudos to evanw for figuring out the registry strategy in https://github.com/evanw/tla-fuzzer
const tlaModule = `export default function register(fn, evaluate_accesses) {
    let state = "ready";
    let whenDones = [];
    let remaining = 1;

    // evaluate eagerly
    evaluate();

    return evaluate;

    function evaluate(whenDone) {
        if (state === "done") {
            if (whenDone)
                whenDone();
            return;
        }
        if (whenDone)
            whenDones.push(whenDone);
        if (state === "busy") {
            return;
        }
        state = "busy";
        let moduleDone = () => {
            state = "done";
            for (let x of whenDones)
                x();
        };
        let importDone = () => {
            if (--remaining !== 0)
                return;
            let result = fn();
            if (result) {
                result.then(moduleDone);
            }
            else {
                moduleDone();
            }
        };
        for (const access of evaluate_accesses) {
            try {
                const evaluate = access(); // throws for cyclic dependencies
                remaining++;
                evaluate(importDone);
            }
            catch (_a) { }
        }
        importDone();
    }
}
`;

export default function concurrentTopLevelAwait(
	options: {
		include?: FilterPattern;
		exclude?: FilterPattern;
		sourceMap?: boolean;
		/**
		 * Prefix used for internal variables generated by the plugin.
		 * Change this if it conflicts with variable names in your code.
		 * @default "__tla"
		 */
		generatedVariablePrefix?: string;
	} = {},
) {
	const filter = createFilter(options.include, options.exclude);

	const generatedVariablePrefix = options.generatedVariablePrefix ?? "__tla";
	const registerModuleSource = `\0${generatedVariablePrefix}Register`;

	const asyncTracker = new AsyncModuleTracker<string>();

	return {
		name: "rollup-plugin-concurrent-tla-plugin",
		// @ts-expect-error vite specific properties
		// vite serves modules as ES modules during dev and thus TLA gets handled natively
		apply: "build" as const,

		resolveId(source) {
			if (source === registerModuleSource) {
				return registerModuleSource;
			}
		},
		load(id) {
			if (id === registerModuleSource) {
				return tlaModule;
			}
		},

		transform: {
			// filter: {
			// 	id: {
			// 		include: options.include ?? undefined,
			// 		exclude: options.exclude ?? undefined,
			// 	},
			// },
			async handler(code, id, transformOptions) {
				if (!filter(id)) return;

				const ast = this.parse(code);

				const importDeclarations = ast.body.filter(
					(a) => a.type === "ImportDeclaration",
				);

				const hasAwait = hasTopLevelAwait(ast);
				asyncTracker.setEntryAsync(id, hasAwait);

				if (hasAwait) {
					// we can skip adding dependencies here, as we know that the module is async anyway
					asyncTracker.setDependencies(id, []);
				}

				let imports = (
					await Promise.all(
						importDeclarations.map(async (declaration) => {
							const importId = await resolveDeclarationSource(
								this,
								id,
								transformOptions?.attributes,
								declaration,
							);
							if (!importId || !filter(importId.id)) return null;
							return {
								declaration,
								id: importId.id,
							};
						}),
					)
				).filter(Boolean) as { declaration: ImportDeclaration; id: string }[];

				if (!hasAwait) {
					asyncTracker.setDependencies(
						id,
						imports.map((x) => x.id),
					);
				}

				const asyncImports = (
					await Promise.all(
						imports.map(async ({ declaration, id }) => {
							// don't await load to not run into deadlock
							this.load({ id });
							if (!(await asyncTracker.isAsync(id))) return null;
							return declaration;
						}),
					)
				).filter(Boolean) as ImportDeclaration[];

				const isAsyncModule = asyncImports.length > 0 || hasAwait;
				if (!isAsyncModule) return;

				const s = new MagicString(code);

				transform(
					s,
					ast,
					registerModuleSource,
					asyncImports,
					hasAwait,
					options.generatedVariablePrefix ?? "__tla",
				);

				return {
					code: s.toString(),
					map:
						options.sourceMap !== false ? s.generateMap({ hires: true }) : null,
				};
			},
		},
		resolveImportMeta(property, { moduleId }) {
			if (property !== "useTla") {
				return;
			}

			const moduleInfo = this.getModuleInfo(moduleId);

			if (moduleInfo?.isEntry) {
				return "true";
			}

			// modules that are dynamically imported must block, so the promise returned
			// by the dynamic import can only resolve once the module is fully evaluated
			if (moduleInfo?.dynamicImporters.length) {
				return "true";
			}

			// modules must behave like ordinary async modules for modules that are not
			// handled by the plugin
			const importers = moduleInfo?.importers;
			if (importers?.some((id) => !filter(id))) {
				return "true";
			}

			return "false";
		},
	} satisfies Plugin;
}
